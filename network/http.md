
## HTTP:
  超文本传输协议，位于OSI网络分层中的应用层，是建立在传输层TCP连接之上的简单无状态的请求响应协议；请求体由请求行，请求头，请求空行，请求主体组成，响应体由响应行，响应头，响应空行，响应主体组成。客户端通过协议规定的各类状态码来判断这次请求响应是否成功/进行下一步操作。

### HTTP请求方法
	  1. GET: 请求指定的页面信息，并返回实体主体。
	  2. HEAD: 和GET类似，只不过不返回报文主体，只返回响应首部。可用于确认URI的有效性及资源更新的日期时间；
	  3. POST: 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
	  4. PUT: 用来传输文件，要求请求报文的主体中包含文件内容，然后保存到请求URI指定的位置。
	  5. DELETE: 和PUT相反，按请求URI删除指定的资源。
	  6. OPTIONS: 用来查询针对请求URI指定的资源支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息
	  7. TRACE: 让服务端将之前的请求通信返回给客户端的方法（因此客户端可以得知请求是怎么一步步到服务端的）。主要用于测试或诊断。
	  8. CONNECT: 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。

### HTTP常见的状态码：、

	  1XX：信息性状态码，表示接收的请求正在处理
	  2XX：成功状态码，表示请求正常处理完毕
	  3XX：重定向状态码，表示需要进行附加操作以完成请求
	  4XX：客户端错误状态码，表示服务器无法处理请求
	  5XX：服务端错误状态码，表示服务器处理请求出错
### HTTP连接管理：
#### 短连接和长连接：
	当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。
	长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信，Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。
##### 优缺点：
	长连接：长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间，对于频繁请求资源的客户来说，较适用长连接。Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可以避免一些恶意连接导致server端服务受损
	短连接：对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。
##### 建立步骤：
	短连接：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
	长连接：建立连接——数据传输...（保持连接）...数据传输——关闭连接
##### 流水线：
	默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。流水线是在同一条长连接上连续发出请求，而不用等待响应返回，减少延迟。但是流水线返回的响应是需要按序的，那么前一个请求如果很耗时（比如处理大图片），那么后面的请求即使服务器已经处理完，仍会等待前面的请求处理完才开始按序返回。

## HTTPS:
由于HTTP是无状态，数据以明文进行传输，不提供数据加密，基于安全性考虑，提出了HTTPS，其就是在TCP协议和HTTP协议之间加了一个SSL/TLS协议，HTTPS中的S便是安全套接字协议。
HTTPS的主要目的就是提供对网站服务器的身份认证，保证数据传输的私密性和完整性，有以下特点：
    1. 内容加密： 采用混合加密技术，中间者无法直接查看明文内容
    2. 验证身份： 通过证书认证客户端访问的是自己的服务器
    3. 保护数据的完整性： 防止传输的内容被中间人冒充或者篡改
    (ps：浏览器端输入https的url，浏览器小锁显示是红的说明数字证书不安全，绿色的说明是CA认证的安全的证书客户端会存放信任的根证书，然后会看服务器发过来的证书是否是这些信任的根证书发的或者信任根的二级证书机构发的，是否在有效期内）
#### 技术前提： 
    1. 对称加密： 采用对称密码编码技术，也就是编码和解码采用相同描述字符，加密和解密采用相同的密钥
    2. 非对称加密： 加密算法需要两个密钥，一对公开密钥和私有密钥，利用公钥加密，只有使用私钥才能解密
    SSL首先对对称加密的密钥使用使用公钥进行非对称加密，链路建立好之后，SSL对传输内容使用对称加密

HTTPS简单来说，是发端将CA认证的证书（包含非对称加密的公钥）传递给收端，收端认证证书合法性，获取公钥，并将利用公钥加密对称加密算法的密钥传递给发端，此后双方通信便用对称加密算法进行数据加密。
#### 认证方法
	双向认证：
		1. 先决条件是有两个或两个以上的证书，一个是服务端证书，另一个或多个是客户端证书；
		2. 服务端保存着客户端的证书并信任该证书，客户端保存着服务端的证书并信任，这样在证书验证成功的情况下即可完成请求响应；
		3. 双向认证一般用于企业应用对接。
	单向认证（上述便是单向认证）：
		1. 客户端保存着服务端的证书并信任该证书；
		2. https一般是单向认证，这样可以让绝大部分人访问你的站点。
	  HTTPS由于多了一层加密，相对于HTTP来说效率较低，这也是利用时间换安全的做法；
## Cookie
#### 作用

	session管理：保存登录，购物车等需要记录的信息
	个性化：保存用户偏好，比如网页字体大小，背景色等等
	追踪： 记录和分析用户行为
#### 规则
	只要域名和端口相同，就可以共享cookie，http://example.com设置的 Cookie，可以被https://example.com读取。
	httpOnly：该属性指定cookie无法通过JS脚本拿到，Document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性，纺织cookie属性被脚本读到，只有浏览器发出http请求才可以带上该cookie
	Secure: 只能通过https协议加密过的请求发送给服务端，
	document.cookie属性用于读写当前网页的 Cookie。例如读取操作：document.cookie // "foo=bar;baz=bar"，document.cookie是可写的，可以通过其为当前网站添加cookie，document.cookie一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加，删除一个现存 Cookie 的唯一方法，是设置它的expires属性为一个过去的日期，例如删除：document.cookie = 'fontSize=;expires=Thu, 01-Jan-1970 00:00:01 GMT'
```javascript
    操作cookie
    const cookieJar = {
        set: function(name, value, days) {
            document.cookie=`${name}=${value};expires=${new Date(Date.now()+days*24*3600*1000)}`
        }
        get: function(name) {
            let cookie = document.cookie
            let reg = new RegExp(`${name}=([^;]+)`)
            let res = reg.exec(cookie)
            return res[1]
        }
        // 删除一个现存 Cookie 的唯一方法，是设置它的expires属性为一个过去的日期
        remove: function(name) {
            document.cookie=`${name}=outdate;expires=${new Date(Date.now()-36110000)}`
        }
    }
```

## TCP
#### TCP三次握手 
	1. 请求由客户端发起第一次握手，A向B发送连接请求，这时连接请求报文段的首部同部位SYN=1，同时选择是一个初始序号seq=x。（TCP规定SYN=1的报文不能携带数据，但是需要消耗一个序号）。A的TCP客户进程进入SYN-SENT
	2.  B收到A的连接请求报文段之后，如果同意建立连接，则向A发送确认。此时确认报文中，ACK=1（对报文的确认），SYN=1，确认号ack=x+1。还要为自己选择一个初始序号seq=y。注意，此报文不能携带数据，但是需要消耗一个序号
	3. A收到B的确认之后，还要向B给出确认。此时确认报文中，ACK=1，ack=y+1, seq=x+1.可以携带数据
	三次握手的原因： 
		两次握手是不稳定的，有一种情况，当A发送的连接请求报文在长时间滞留的情况下进行超时重传，这次成功与B建立起连接，并且在数据传输完成之后释放链接。当A的第一次请求到达B时候，这个报文应该作废，但是B以为A要重新建立连接，于是B向A发送确认报文，同意连接请求。如果是两次握手，在这时B认为连接已经建立。而A并没有发出建立连接的请求，所以不会理会B的确认，也不会向B发送数据，但是B认为连接已建立，就一直等待A发送数据，导致资源的浪费。
#### TCP四次挥手：
	1. A向B发送连接释放报文，此时报文首部FIN=1，其序号seq=u（u等于前面已传送数据的最后一个字节的序号+1），此时A进入FIN-WAIT-1（终止等待1状态）。等待B的确认。注意，TCP规定，即使FIN报文段不携带数据，也会消耗一个序号
	2. 第二次挥手 B收到连接释放报文时会发出确认，此时确认报文首部ACK=1，ack=u+1，seq=v（v等于前面已传送数据的最后一个字节的序号+1），此时B进入CLOSE-WAIT（关闭等待状态）
	3.第三次挥手 如果B没有数据发送给A，此时B就应该释放连接，B会发送连接释放报文，此时报文首部FIN=1，确认号ack=u+1（A->B的连接被释放，A不可能在发送数据到B，所以确认号不变），B的序号seq=w（在半关闭状态B可能向A发送了数据，会导致B的序号改变）。此时B进入LAST-ACK（最后确认状态），等待A的确认。
	4. 第四次挥手 A在收到B的连接释放请求后必须确认，此时确认报文首部ACK=1，ack=w+1，seq=u+1，此时A进入到TIME-WAIT（时间等待状态）。注意，此时TCP连接没有释放掉。必须等到时间等待计数器设置的时间2MSL（MSL为最长报文寿命）后，A才会进入到CLOSED状态。B收到A的确认后就会进入到CLOSED状态。此时A和B之间的连接被完全释放。
	四次挥手的原因：
	TCP是全双工得到，意味着当A发出FIN报文段时候，只是表示A已经没有数据可以发送了，A告诉B数据发送完毕，A要断开A->B的单向连接；但是，这个时候A还是可以接受来自B的数据，当B返回ACK报文段时，表示它已经知道A没有数据发送了，但是B还是可以发送数据到A的；当B也发送了FIN报文段时，这个时候就表示B也没有数据要发送了，就会告诉A，我也没有数据要发送了，这时B要断开B->A的单项连接，当这条连接也被释放，那么连接就真正的释放掉了。
#### TCP流量控制
	流量控制是为了控制发送方发送速率，保证接收方来得及接收
	接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方发送速率，将窗口字段设置为0，则发送方不能发送数据
#### TCP拥塞控制
	流量控制是为了让接收方来得及接收，拥塞控制是为了降低整个网络的拥塞程度
	TCP主要通过：慢开始 拥塞避免 快重传 快恢复 来进行拥塞控制
讨论拥塞控制时候假设：
	1. 接收方有足够大的接受缓存，因此不会发生流量控制
	2. 虽然TCP的窗口基于字节，这里的窗口大小单位为报文段
(ps: 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。)
	发送方维护一个拥塞窗口(cwnd)的变量，拥塞窗口与发送窗口的区别： 拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送窗口
